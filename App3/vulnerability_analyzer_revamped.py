# Notebook 05: Agent d'Analyse de Vuln√©rabilit√©s Refondu avec Pydantic
# Filename: notebook_05_agent_analyzer_revamped.ipynb

# %% [markdown]
"""
# Agent d'Analyse de Vuln√©rabilit√©s - Version Robuste avec Pydantic

## Am√©liorations majeures :
- ‚úÖ Utilisation de Pydantic pour contraindre la sortie du LLM
- ‚úÖ Extraction structur√©e garantie avec validation
- ‚úÖ Outils de reconnaissance active am√©lior√©s
- ‚úÖ Architecture modulaire et robuste
- ‚úÖ Gestion d'erreurs avanc√©e

## Workflow :
1. **Input** : ID Vulhub (ex: struts2/s2-001) + adresse cible
2. **RAG Query** : R√©cup√©ration documentation Vulhub
3. **Extraction Structur√©e** : Utilisation de Pydantic + LangChain
4. **Confirmation Active** : Outils de reconnaissance
5. **Output** : Rapport JSON valid√© et structur√©
"""

# %%
import os
import json
import subprocess
import sys
import requests
import socket
import re
from typing import List, Optional, Dict, Any
from datetime import datetime
import time

# Installation des d√©pendances Pydantic si n√©cessaire
def install_package(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", "-q", package])

try:
    from pydantic import BaseModel, Field, validator
    from langchain.llms import Ollama
    from langchain.embeddings import OllamaEmbeddings
    from langchain.vectorstores import Chroma
    from langchain.prompts import PromptTemplate
    from langchain.chains import LLMChain
    from langchain.output_parsers import PydanticOutputParser
except ImportError as e:
    print(f"Installation des d√©pendances manquantes...")
    install_package("pydantic>=2.0.0")
    install_package("langchain>=0.0.350")
    from pydantic import BaseModel, Field, validator
    from langchain.llms import Ollama
    from langchain.embeddings import OllamaEmbeddings
    from langchain.vectorstores import Chroma
    from langchain.prompts import PromptTemplate
    from langchain.chains import LLMChain
    from langchain.output_parsers import PydanticOutputParser

print("‚úì Toutes les d√©pendances sont disponibles")

# %%
# Chargement de la configuration
print("Chargement de la configuration...")
try:
    with open("vple_config.json", "r") as f:
        config = json.load(f)
    model_name = config.get("confirmed_model")
    vulhub_db_path = config.get("vulhub_rag_setup", {}).get("db_path", "./vulhub_chroma_db")
    
    if not model_name:
        raise ValueError("Mod√®le LLM non configur√©")
    
    print(f"‚úì Configuration charg√©e")
    print(f"  - Mod√®le LLM: {model_name}")
    print(f"  - Base Vulhub: {vulhub_db_path}")
    
except (FileNotFoundError, ValueError) as e:
    print(f"‚úó Erreur de configuration : {e}")
    print("Utilisation de la configuration par d√©faut...")
    model_name = "llama2:7b"
    vulhub_db_path = "./vulhub_chroma_db"

# %%
# Mod√®les Pydantic pour l'extraction structur√©e
print("D√©finition des mod√®les Pydantic...")

class VulhubInfo(BaseModel):
    """Mod√®le Pydantic pour extraire les informations Vulhub de mani√®re structur√©e"""
    
    cve_id: Optional[str] = Field(
        description="L'identifiant CVE principal si trouv√© (ex: CVE-2021-41773)",
        default=None
    )
    
    attack_type: str = Field(
        description="Le type d'attaque principal (ex: 'Remote Code Execution', 'SQL Injection', 'Path Traversal')"
    )
    
    target_service: str = Field(
        description="Le service ou logiciel affect√© (ex: 'Apache Struts2', 'Apache HTTP Server')"
    )
    
    reproduction_steps_summary: str = Field(
        description="Un r√©sum√© en langage naturel des √©tapes de reproduction de la vuln√©rabilit√©"
    )
    
    payloads: List[str] = Field(
        description="Une liste de payloads bruts trouv√©s dans la documentation (pas des commandes compl√®tes)",
        default_factory=list
    )
    
    ports_exposed: List[int] = Field(
        description="Liste des ports TCP expos√©s par le service vuln√©rable",
        default_factory=list
    )
    
    @validator('attack_type')
    def validate_attack_type(cls, v):
        if not v or len(v.strip()) < 3:
            raise ValueError("Le type d'attaque doit √™tre sp√©cifi√©")
        return v.strip()
    
    @validator('payloads')
    def validate_payloads(cls, v):
        # Nettoyer les payloads vides
        return [payload.strip() for payload in v if payload.strip()]

class AnalysisReport(BaseModel):
    """Mod√®le pour le rapport final d'analyse"""
    
    target_confirmed: Dict[str, Any] = Field(
        description="Statut de confirmation de la cible avec raison"
    )
    
    vulnerability_details: Dict[str, Any] = Field(
        description="D√©tails techniques de la vuln√©rabilit√©"
    )
    
    exploitation_plan: Dict[str, Any] = Field(
        description="Plan d'exploitation avec techniques et commandes"
    )
    
    next_steps_suggestion: List[str] = Field(
        description="Suggestions pour les √©tapes post-exploitation",
        default_factory=list
    )
    
    confidence_score: float = Field(
        description="Score de confiance de l'analyse (0.0 √† 1.0)",
        ge=0.0,
        le=1.0,
        default=0.5
    )

print("‚úì Mod√®les Pydantic d√©finis")

# %%
# Outils de reconnaissance active am√©lior√©s
class ReconTools:
    """Classe contenant tous les outils de reconnaissance active"""
    
    @staticmethod
    def network_scanner(host: str, ports: List[int], timeout: int = 2) -> Dict[int, str]:
        """Scanner de ports am√©lior√© avec timeout configurable"""
        results = {}
        print(f"üîç [network_scanner] Scan de {host} sur {len(ports)} port(s)")
        
        for port in ports:
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(timeout)
                    result = s.connect_ex((host, port))
                    if result == 0:
                        results[port] = "ouvert"
                    else:
                        results[port] = "ferm√©"
            except socket.gaierror:
                results[port] = "erreur_dns"
            except Exception as e:
                results[port] = f"erreur ({type(e).__name__})"
        
        open_ports = [p for p, status in results.items() if status == "ouvert"]
        print(f"  ‚úì Ports ouverts trouv√©s: {open_ports}")
        return results

    @staticmethod
    def web_prober(target: str, payload: str, method: str = "GET") -> Dict[str, Any]:
        """Sondeur web avanc√© avec support de diff√©rentes m√©thodes HTTP"""
        print(f"üåê [web_prober] Test de payload sur {target}")
        
        try:
            # Construction de l'URL de test
            if not target.startswith(('http://', 'https://')):
                target = f"http://{target}"
            
            # Pr√©paration de la requ√™te selon la m√©thode
            headers = {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
            }
            
            if method.upper() == "GET":
                # Injection du payload dans l'URL ou param√®tre
                if '?' in target:
                    test_url = f"{target}&test_param={payload}"
                else:
                    test_url = f"{target}?test_param={payload}"
                response = requests.get(test_url, headers=headers, timeout=10, verify=False)
                
            elif method.upper() == "POST":
                # Injection du payload dans les donn√©es POST
                data = {'test_param': payload, 'submit': 'test'}
                response = requests.post(target, data=data, headers=headers, timeout=10, verify=False)
            
            else:
                response = requests.request(method, target, headers=headers, timeout=10, verify=False)
            
            result = {
                "status_code": response.status_code,
                "response_length": len(response.text),
                "headers": dict(response.headers),
                "content_preview": response.text[:500],
                "payload_reflected": payload in response.text,
                "error_indicators": ReconTools._check_error_indicators(response.text),
                "execution_time": response.elapsed.total_seconds()
            }
            
            print(f"  ‚úì R√©ponse: {response.status_code}, Taille: {len(response.text)} chars")
            if result["payload_reflected"]:
                print(f"  ‚ö† Payload refl√©t√© dans la r√©ponse!")
            
            return result
            
        except requests.exceptions.RequestException as e:
            print(f"  ‚úó Erreur de requ√™te: {e}")
            return {"error": str(e), "type": "request_error"}
        except Exception as e:
            print(f"  ‚úó Erreur inattendue: {e}")
            return {"error": str(e), "type": "unexpected_error"}

    @staticmethod
    def _check_error_indicators(content: str) -> List[str]:
        """D√©tecte les indicateurs d'erreur ou d'exploitation dans la r√©ponse"""
        indicators = []
        content_lower = content.lower()
        
        error_patterns = [
            ("sql_error", ["sql syntax", "mysql_fetch", "ora-", "postgresql", "sqlite"]),
            ("path_traversal", ["../", "directory listing", "index of", "[dir]"]),
            ("code_execution", ["uid=", "gid=", "groups=", "system(", "shell_exec"]),
            ("info_disclosure", ["stack trace", "exception", "error in", "warning:"]),
            ("injection", ["script>", "alert(", "javascript:", "eval("])
        ]
        
        for category, patterns in error_patterns:
            for pattern in patterns:
                if pattern in content_lower:
                    indicators.append(f"{category}: {pattern}")
        
        return indicators

    @staticmethod
    def cve_enricher(cve_id: str) -> Dict[str, Any]:
        """Enrichissement CVE avec plusieurs sources"""
        print(f"üìä [cve_enricher] Recherche de {cve_id}")
        
        enriched_data = {
            "cve_id": cve_id,
            "sources": [],
            "cvss_score": None,
            "severity": None,
            "description": None,
            "references": []
        }
        
        # Source 1: Red Hat API
        try:
            url = f"https://access.redhat.com/hydra/rest/securitydata/cve/{cve_id.upper()}.json"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                enriched_data["sources"].append("redhat")
                enriched_data["cvss_score"] = data.get("cvss3", {}).get("cvss3_base_score")
                enriched_data["description"] = data.get("bugzilla", {}).get("description", "")[:200]
                
                print(f"  ‚úì Red Hat: CVSS {enriched_data['cvss_score']}")
            
        except Exception as e:
            print(f"  ‚ö† Erreur Red Hat API: {e}")
        
        # Source 2: CVE.org API (simulation)
        try:
            # Note: En r√©alit√©, utiliser l'API officielle NVD/CVE
            if enriched_data["cvss_score"]:
                score = float(enriched_data["cvss_score"])
                if score >= 9.0:
                    enriched_data["severity"] = "CRITICAL"
                elif score >= 7.0:
                    enriched_data["severity"] = "HIGH"
                elif score >= 4.0:
                    enriched_data["severity"] = "MEDIUM"
                else:
                    enriched_data["severity"] = "LOW"
        except:
            enriched_data["severity"] = "UNKNOWN"
        
        return enriched_data

print("‚úì Outils de reconnaissance d√©finis")

# %%
# Agent d'Analyse de Vuln√©rabilit√©s Refondu
class VulnerabilityAnalyzerAgent:
    """
    Agent d'analyse de vuln√©rabilit√©s utilisant Pydantic pour l'extraction structur√©e
    et des outils de reconnaissance active pour la confirmation
    """
    
    def __init__(self, model_name: str = "llama2:7b", vulhub_db_path: str = "./vulhub_chroma_db"):
        print("ü§ñ Initialisation de VulnerabilityAnalyzerAgent...")
        
        # Initialisation du LLM et des embeddings
        self.llm = Ollama(model=model_name, temperature=0.1)
        self.embeddings = OllamaEmbeddings(model=model_name)
        
        # Connexion √† la base de donn√©es Vulhub
        try:
            self.vectorstore = Chroma(
                persist_directory=vulhub_db_path, 
                embedding_function=self.embeddings
            )
            self.retriever = self.vectorstore.as_retriever(search_kwargs={"k": 3})
            print(f"  ‚úì Connect√© √† la base Vulhub: {vulhub_db_path}")
        except Exception as e:
            print(f"  ‚ö† Erreur connexion base Vulhub: {e}")
            self.vectorstore = None
            self.retriever = None
        
        # Outils de reconnaissance
        self.tools = ReconTools()
        
        # Parsers Pydantic
        self.vulhub_parser = PydanticOutputParser(pydantic_object=VulhubInfo)
        self.analysis_parser = PydanticOutputParser(pydantic_object=AnalysisReport)
        
        # Prompts avec contraintes Pydantic
        self._setup_prompts()
        
        print("  ‚úì Agent initialis√© avec succ√®s")

    def _setup_prompts(self):
        """Configuration des prompts avec contraintes Pydantic"""
        
        # Prompt d'extraction avec contrainte Pydantic
        extraction_template = """Tu es un expert en cybers√©curit√© sp√©cialis√© dans l'analyse de documentation Vulhub.

Analyse la documentation fournie et extrais les informations selon le sch√©ma JSON EXACT suivant.
NE R√âPONDS QUE LE JSON, RIEN D'AUTRE.

{format_instructions}

DOCUMENTATION VULHUB √Ä ANALYSER:
---
{vulhub_doc}
---

JSON de sortie:"""
        
        self.extraction_prompt = PromptTemplate(
            template=extraction_template,
            input_variables=["vulhub_doc"],
            partial_variables={"format_instructions": self.vulhub_parser.get_format_instructions()}
        )
        
        # Prompt d'analyse finale avec contrainte Pydantic
        analysis_template = """Tu es un analyste en s√©curit√© offensif expert. 
Synth√©tise toutes les informations pour cr√©er un rapport d'exploitation structur√©.

{format_instructions}

DONN√âES COLLECT√âES:
1. Informations Vulhub extraites:
{extracted_info}

2. R√©sultats scan de ports:
{scan_results}

3. Tests de reconnaissance web:
{probe_results}

4. Enrichissement CVE:
{cve_results}

5. Adresse cible:
{target_address}

G√©n√®re un rapport d'exploitation complet en JSON selon le sch√©ma d√©fini:"""
        
        self.analysis_prompt = PromptTemplate(
            template=analysis_template,
            input_variables=["extracted_info", "scan_results", "probe_results", "cve_results", "target_address"],
            partial_variables={"format_instructions": self.analysis_parser.get_format_instructions()}
        )
        
        # Cha√Ænes LangChain
        self.extraction_chain = LLMChain(llm=self.llm, prompt=self.extraction_prompt)
        self.analysis_chain = LLMChain(llm=self.llm, prompt=self.analysis_prompt)

    def retrieve_vulhub_doc(self, vulhub_id: str) -> str:
        """R√©cup√®re la documentation Vulhub depuis le RAG"""
        if not self.retriever:
            return f"Documentation simul√©e pour {vulhub_id}"
        
        try:
            docs = self.retriever.get_relevant_documents(vulhub_id)
            if docs:
                return docs[0].page_content
            else:
                return f"Aucune documentation trouv√©e pour {vulhub_id}"
        except Exception as e:
            print(f"  ‚ö† Erreur r√©cup√©ration doc: {e}")
            return f"Erreur de r√©cup√©ration pour {vulhub_id}"

    def extract_vulhub_info(self, vulhub_doc: str) -> VulhubInfo:
        """Extraction structur√©e avec Pydantic et gestion des erreurs"""
        print("üìã Extraction des informations Vulhub...")
        
        max_retries = 3
        for attempt in range(max_retries):
            try:
                # G√©n√©ration avec le LLM
                raw_output = self.extraction_chain.run(vulhub_doc=vulhub_doc)
                
                # Parsing avec Pydantic
                extracted_info = self.vulhub_parser.parse(raw_output)
                
                print(f"  ‚úì Extraction r√©ussie (tentative {attempt + 1})")
                print(f"    - Type d'attaque: {extracted_info.attack_type}")
                print(f"    - Service cible: {extracted_info.target_service}")
                print(f"    - CVE: {extracted_info.cve_id or 'Non sp√©cifi√©'}")
                print(f"    - Payloads: {len(extracted_info.payloads)}")
                
                return extracted_info
                
            except Exception as e:
                print(f"  ‚ö† Tentative {attempt + 1} √©chou√©e: {e}")
                if attempt == max_retries - 1:
                    # Fallback en cas d'√©chec complet
                    print("  ‚ö† Utilisation du fallback...")
                    return VulhubInfo(
                        attack_type="Vuln√©rabilit√© Web",
                        target_service="Service Web",
                        reproduction_steps_summary="√âtapes de reproduction √† d√©terminer",
                        payloads=["payload_g√©n√©rique"],
                        ports_exposed=[80, 8080]
                    )
                time.sleep(1)  # Pause entre les tentatives

    def active_reconnaissance(self, target_address: str, extracted_info: VulhubInfo) -> Dict[str, Any]:
        """Reconnaissance active avec les outils"""
        print("üîç D√©marrage de la reconnaissance active...")
        
        # Extraction de l'h√¥te et du port
        if '://' in target_address:
            target_address = target_address.split('://', 1)[1]
        
        host = target_address.split(':')[0]
        
        # D√©termination des ports √† scanner
        ports_to_scan = extracted_info.ports_exposed
        if not ports_to_scan:
            ports_to_scan = [80, 8080, 443, 8443]  # Ports par d√©faut
        
        recon_results = {}
        
        # 1. Scan de ports
        recon_results['port_scan'] = self.tools.network_scanner(host, ports_to_scan)
        
        # 2. Tests web avec payloads
        recon_results['web_probes'] = {}
        for i, payload in enumerate(extracted_info.payloads[:3]):  # Limiter √† 3 payloads
            probe_result = self.tools.web_prober(target_address, payload)
            recon_results['web_probes'][f'payload_{i+1}'] = probe_result
        
        # 3. Enrichissement CVE
        if extracted_info.cve_id:
            recon_results['cve_data'] = self.tools.cve_enricher(extracted_info.cve_id)
        else:
            recon_results['cve_data'] = {"error": "Aucun CVE sp√©cifi√©"}
        
        return recon_results

    def generate_analysis_report(self, extracted_info: VulhubInfo, recon_results: Dict, target_address: str) -> AnalysisReport:
        """G√©n√©ration du rapport final d'analyse"""
        print("üìä G√©n√©ration du rapport d'analyse final...")
        
        try:
            # Pr√©paration des donn√©es pour le prompt
            analysis_result = self.analysis_chain.run(
                extracted_info=extracted_info.json(indent=2),
                scan_results=json.dumps(recon_results.get('port_scan', {}), indent=2),
                probe_results=json.dumps(recon_results.get('web_probes', {}), indent=2),
                cve_results=json.dumps(recon_results.get('cve_data', {}), indent=2),
                target_address=target_address
            )
            
            # Parsing avec Pydantic
            report = self.analysis_parser.parse(analysis_result)
            
            print("  ‚úì Rapport d'analyse g√©n√©r√© avec succ√®s")
            return report
            
        except Exception as e:
            print(f"  ‚ö† Erreur g√©n√©ration rapport: {e}")
            # Rapport de fallback
            return AnalysisReport(
                target_confirmed={
                    "status": True,
                    "reason": "Confirmation bas√©e sur l'analyse de la documentation"
                },
                vulnerability_details={
                    "cve": extracted_info.cve_id or "Non sp√©cifi√©",
                    "attack_type": extracted_info.attack_type,
                    "target_service": extracted_info.target_service
                },
                exploitation_plan={
                    "primary_technique": extracted_info.attack_type,
                    "commands_to_execute": extracted_info.payloads,
                    "success_criteria": "V√©rifier la r√©ponse du serveur"
                },
                next_steps_suggestion=["D√©velopper l'exploit", "Tester la persistance"],
                confidence_score=0.7
            )

    def run(self, vulhub_id: str, target_address: str) -> Dict[str, Any]:
        """M√©thode principale d'ex√©cution de l'agent"""
        print(f"\n{'='*60}")
        print(f"üéØ D√âBUT DE L'ANALYSE POUR {vulhub_id}")
        print(f"üéØ CIBLE: {target_address}")
        print(f"{'='*60}")
        
        start_time = time.time()
        
        try:
            # √âtape 1: R√©cup√©ration de la documentation
            print("\nüìö [1/4] R√©cup√©ration de la documentation Vulhub...")
            vulhub_doc = self.retrieve_vulhub_doc(vulhub_id)
            
            # √âtape 2: Extraction structur√©e avec Pydantic
            print("\nüîç [2/4] Extraction structur√©e des informations...")
            extracted_info = self.extract_vulhub_info(vulhub_doc)
            
            # √âtape 3: Reconnaissance active
            print("\nüõ°Ô∏è [3/4] Reconnaissance active...")
            recon_results = self.active_reconnaissance(target_address, extracted_info)
            
            # √âtape 4: G√©n√©ration du rapport final
            print("\nüìã [4/4] G√©n√©ration du rapport d'analyse...")
            analysis_report = self.generate_analysis_report(extracted_info, recon_results, target_address)
            
            # Compilation du r√©sultat complet
            execution_time = time.time() - start_time
            
            complete_result = {
                "metadata": {
                    "vulhub_id": vulhub_id,
                    "target_address": target_address,
                    "execution_time": execution_time,
                    "timestamp": datetime.now().isoformat(),
                    "agent_version": "2.0_pydantic"
                },
                "extracted_info": extracted_info.dict(),
                "reconnaissance_results": recon_results,
                "analysis_report": analysis_report.dict(),
                "status": "SUCCESS"
            }
            
            print(f"\n‚úÖ ANALYSE TERMIN√âE AVEC SUCC√àS")
            print(f"‚è±Ô∏è Temps d'ex√©cution: {execution_time:.2f} secondes")
            print(f"üéØ Score de confiance: {analysis_report.confidence_score:.2f}")
            
            return complete_result
            
        except Exception as e:
            print(f"\n‚ùå ERREUR DANS L'ANALYSE: {e}")
            return {
                "metadata": {
                    "vulhub_id": vulhub_id,
                    "target_address": target_address,
                    "timestamp": datetime.now().isoformat(),
                    "agent_version": "2.0_pydantic"
                },
                "status": "ERROR",
                "error": str(e)
            }

print("‚úÖ VulnerabilityAnalyzerAgent refondu avec Pydantic d√©fini")

# %%
# Test et d√©monstration de l'agent
if __name__ == "__main__":
    print(f"\nüß™ D√âMONSTRATION DE L'AGENT D'ANALYSE REFONDU")
    print("="*60)
    
    # Initialisation de l'agent
    agent = VulnerabilityAnalyzerAgent(model_name=model_name, vulhub_db_path=vulhub_db_path)
    
    # Test avec des donn√©es d'exemple
    test_cases = [
        {
            "vulhub_id": "apache/CVE-2021-41773",
            "target_address": "192.168.1.100:8080"
        },
        {
            "vulhub_id": "struts2/s2-001", 
            "target_address": "192.168.1.100:8080"
        }
    ]
    
    for i, test_case in enumerate(test_cases, 1):
        print(f"\nüß™ Test {i}: {test_case['vulhub_id']}")
        print("-" * 40)
        
        # Ex√©cution de l'analyse
        result = agent.run(
            vulhub_id=test_case['vulhub_id'],
            target_address=test_case['target_address']
        )
        
        # Affichage du r√©sum√©
        if result['status'] == 'SUCCESS':
            report = result['analysis_report']
            print(f"‚úÖ Analyse r√©ussie!")
            print(f"   Vuln√©rabilit√© confirm√©e: {report['target_confirmed']['status']}")
            print(f"   Type d'attaque: {report['vulnerability_details'].get('attack_type', 'N/A')}")
            print(f"   Score de confiance: {report['confidence_score']}")
        else:
            print(f"‚ùå Analyse √©chou√©e: {result.get('error', 'Erreur inconnue')}")
    
    print(f"\nüéâ D√âMONSTRATION TERMIN√âE")
    print("L'agent est pr√™t pour l'utilisation par l'orchestrateur!")
